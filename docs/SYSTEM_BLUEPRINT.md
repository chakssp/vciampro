# Blueprint & Technical Guide: System State Synthesis & Recovery

**TASK ID:** DOC-SYN-001
**STATUS:** COMPLETE

---

### **1. Directive Overview & Agent Persona Configuration**

#### **1.1. Primary Objective**
This document is a comprehensive technical guide and architectural blueprint, with all content synthesized directly and exclusively from the current state of the source code.

#### **1.2. Required Persona**
This document was generated by an expert AI Software Architect specializing in Context Engineering and Codebase Synthesis. All analysis and output adhere to KISS (Keep It Simple, Stupid) and RSOP (Reasonable Suite of Practices) principles.

#### **1.3. Deliverable Purpose**
This document serves as the official Single Source of Truth (SSOT). It is the definitive onboarding guide for human developers and the foundational context for all future refactoring and evolution tasks.

---

### **2. Technical Documentation & System Context**

#### **2.1. Project Synopsis**
The project is an AI-powered co-creative tool designed to evolve a user's raw text content by applying semantic context. Users provide this context through a system of predefined tags and a curated list of high-priority, user-defined keywords ("Reinforced Intentions").

**Key Features:**
*   **Content Input:** Text can be provided via direct entry, uploading a text file, or loaded from an auto-saved draft stored in the browser's local storage.
*   **Multi-layered Context Engineering:** Users guide the AI by selecting from predefined tags and adding custom keywords. The importance of these keywords can be increased ("Intent Intensity") to give them more weight in the AI's analysis.
*   **AI-driven Content Evolution:** The application uses Google Gemini models to rewrite and improve the user's content based on the provided context. A "Thinking Mode" is available, which leverages the more powerful `gemini-2.5-pro` model for deeper analysis of complex documents.
*   **Interactive Results:** The evolved content is displayed with features for copying, downloading as a Markdown file, and translation. Users can also select text from the output to create new reinforced keywords or form analysis groups.
*   **Context Persistence & Discovery:** The user's curated context (tags and keywords) can be exported to and imported from a JSON file. The import process includes an AI-powered "discovery engine" that analyzes the imported content to suggest new, relevant keywords to the user.
*   **Iterative Refinement:** After an initial generation, users can provide further instructions to the AI to refine the evolved content in a conversational loop.

#### **2.2. Core Technology Stack**
The complete technology stack, as inferred from the source code, is as follows. A primary concern is the lack of a formal testing framework.

| Category      | Technology        | Version    | Notes / Key Libraries                                             |
|---------------|-------------------|------------|-------------------------------------------------------------------|
| Language      | TypeScript        | ~5.x       | Inferred from modern syntax and features.                         |
| Runtime       | Browser           | N/A        | The application runs entirely on the client-side.                 |
| UI Library    | React             | ^19.2.0    | Utilizes hooks for state and lifecycle management.                |
| Styling       | TailwindCSS       | 3.x        | Loaded via CDN for utility-first styling.                         |
| State Mgt.    | React Hooks       | N/A        | `useState` and custom hooks (e.g., `useHistoryState`).            |
| API Layer     | `@google/genai`   | ^1.27.0    | Direct client-side SDK for Google Gemini API calls.               |
| Persistence   | `localStorage`    | N/A        | Browser API for auto-saving drafts.                               |
| Deployment    | Static Files      | N/A        | Served as `index.html`. No build step is present.                 |
| **Testing**   | **N/A**           | **N/A**    | **No testing frameworks or files are present in the codebase.**   |

#### **2.3. Local Development Environment Setup**
**Prerequisites:**
1.  A modern web browser that supports ES Modules and `importmap`.
2.  A local web server to serve the project files (e.g., `npx serve`). The browser cannot open `index.html` directly from the filesystem due to security restrictions on module loading.

**Installation Steps:**
```bash
# 1. Clone the repository
git clone <repository_url>
cd <project_directory_name>

# 2. No dependency installation is required.
# All dependencies are loaded from a CDN via the importmap in index.html.

# 3. Setup environment variables
# The application expects the Gemini API key to be available in the execution environment.
# This must be set in the deployment context (e.g., as a platform secret).
```

**Environment Configuration:**
*   `process.env.API_KEY`: The Google Gemini API key. This is a hard requirement for the application to function.

#### **2.4. Key Scripts & Commands**
There is no `package.json` file. The sole command required for local execution is:
```bash
npx serve .
```

#### **2.5. Architectural Map**
The project follows a standard client-side structure with a clear separation of concerns, although the main `App.tsx` component is monolithic.

```
/
├── index.html                    # Main entry point, loads scripts and defines dependency importmap.
├── index.tsx                     # Renders the root React component into the DOM.
├── App.tsx                       # **MONOLITHIC** root component managing all application state and UI logic.
├── README.md                     # Project Readme
├── metadata.json                 # Application metadata for the hosting environment.
├── constants.ts                  # Defines static data, like the predefined tag categories.
├── types.ts                      # Contains shared TypeScript type definitions.
├── /components/                  # Shared, reusable UI components.
│   ├── Gauge.tsx                 # Visualizes the semantic relevance score.
│   ├── SuggestionDisplay.tsx     # Renders and manages interactions with the AI's output.
│   └── icons.tsx                 # A library of SVG icons.
├── /services/
│   └── geminiService.ts          # Encapsulates all logic for Gemini API calls and prompt engineering.
└── /docs/
    ├── SYSTEM_BLUEPRINT.md       # **THIS FILE**: The synthesized architectural guide.
    ├── blueprint.html            # Visual context map of the application flow.
    └── blueprint-instruction-development.md # Source directive for this blueprint.
```

---

### **3. Architectural Analysis & Strategic Planning**

#### **3.1. Architectural Pattern Identification**
*   **Client-Side SPA:** The application is a Single-Page Application running entirely in the browser.
*   **Component-Based UI:** The interface is built with React, following a component-based model.
*   **Lifted State:** All major application state is managed ("lifted") into the root `App.tsx` component and passed down to children via props.
*   **Direct API Communication:** The application communicates directly from the client to the external Google Gemini API via the `@google/genai` SDK, with no application backend.

#### **3.2. Code Quality & Concern Analysis**
The codebase adheres to several reasonable practices but also contains critical areas for improvement.

**Positive Findings:**
*   **Good Separation of Concerns:** API logic (`services`), UI components (`components`), type definitions (`types`), and constants (`constants`) are cleanly separated into dedicated modules.
*   **Strong Encapsulation of API Logic:** All prompt engineering and interaction with the Gemini API are encapsulated within `geminiService.ts`, making this logic easy to maintain and evolve.

**Critical Code Smells:**
*   **Critical Concern: Component Monolith:** `App.tsx` is a "god component" that manages nearly all application state, UI logic, and side effects. This significantly hinders readability, maintainability, and scalability.
*   **High Concern: No Build System:** The reliance on a CDN and `importmap` is effective for prototyping but lacks the robustness of a package manager (`pnpm`/`npm`) and a build tool (`Vite`/`Webpack`). This prevents dependency version locking, code optimization, and modern development features like Hot Module Replacement (HMR).
*   **Medium Concern: Manual DOM Manipulation:** The logic in `handleContentMouseUp` to calculate the position of selected text is complex and brittle, relying on a "mirror div" for calculations, which can be unreliable across different browsers and CSS configurations.

#### **3.3. Backlog Generation**

*   **Technical Debt (High Priority):**
    *   **Refactor `App.tsx`:** Decompose the main component into multiple smaller, focused custom hooks (e.g., `useCustomTags`, `useFileIO`) and/or container components to improve readability and separation of concerns.
    *   **Establish Build System:** Integrate `pnpm` and `Vite` to manage dependencies, provide a robust dev server with HMR, and enable optimized production builds.

*   **Refactoring Opportunities (Medium Priority):**
    *   **Introduce State Management Library:** For future growth, adopt a lightweight global state manager (e.g., `Zustand`) to decouple core state from the `App` component, preventing excessive prop drilling.
    *   **Abstract Prompt Construction:** Create a "Prompt Builder" utility within `geminiService.ts` to assemble complex prompts from smaller, reusable, and more testable parts.

*   **New Features (Future Evolution):**
    *   **Implement Streaming Responses:** Modify `geminiService.ts` and `SuggestionDisplay.tsx` to use `generateContentStream` for a significantly improved user experience, showing results as they are generated.
    *   **Add Comparative (Diff) View:** Create a new component that displays a side-by-side comparison of the original content and the evolved content, highlighting changes.
    *   **Expand Profile Management:** Build upon the import/export feature to allow users to save multiple named "context profiles" within `localStorage` and easily switch between them.

*   **Questions for Human Collaborators:**
    1.  What is the target production environment? Understanding the deployment constraints is critical before introducing a build system.
    2.  Is the current undo/redo history, which saves the entire app state on each change, performant enough for very large documents, or should a more granular, action-based history be considered?

#### **3.4. Incremental Evolution Roadmap**

1.  **Phase 1: Foundational Refactoring (Immediate Term)**
    *   **Goal:** Address the most critical technical debt to improve maintainability.
    *   **Tasks:**
        1.  Integrate `pnpm` and `Vite` to establish a modern build process and development environment.
        2.  Begin refactoring `App.tsx` by extracting the `useHistoryState` hook and at least one other major piece of logic (e.g., file import/export) into its own custom hook.

2.  **Phase 2: Core User Experience (Short Term)**
    *   **Goal:** Deliver high-impact improvements to the core user workflow.
    *   **Tasks:**
        1.  Implement streaming AI responses to eliminate the wait for `Generate`.
        2.  Create the side-by-side "diff" view for easier comparison of results.

3.  **Phase 3: Power Features & Scalability (Mid Term)**
    *   **Goal:** Enhance capabilities for advanced users and prepare for future complexity.
    *   **Tasks:**
        1.  Implement the local "Profile Management" system.
        2.  Introduce a global state manager like `Zustand` to prepare for further component decomposition.
